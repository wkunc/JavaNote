# 映射值类型

## 映射基本属性
如果属性是基本属性或者其包装类型, 或者是 String, BigInteger, BigDecimal,
java.util.Date, java.util.Calendar, java.sql.Date, java.sql.Time, java.sql
.Timestamp, byte[], Byte[], char[] 和 Character[]

如果将属性的类注解为 @Embeddable, 或者将属性本身映射为 @Embedded,
则 Hibernate 会将该属性映射为所属类的可嵌入组件

如果属性的类型是 java.io.Serializable, 则会使用以其序列化格式存储

### 重写基本属性的默认配置
上面说到 Hibernate 会自动持久化一个类的所有属性,而有些临时属性在运行时期确定的值
是不应该持久化的.

这时候就应该使用 @javax.persistence.Transient 注解或者使用 Java transient(短暂的) 关键字
标记属性或者该字段的 getter 方法告诉JPA这个字段不用持久化

如果不希望依赖属性映射默认配置, 那么可以将 @Basic 注解应用到某个特定属性

## 使用派生属性
@Formula(公式)
派生属性的值是在运行时通过估算 @org.hibernate.annotations.Formula 注解声明的 SQL 表达式来计算的
```java
@Formula("substr(DESCRIPTION, 1, 12) || '...'")
private String shortDescription;
@Formula("(select avg(b.AMOUNT) from BID b where b.ITEM_ID == ID)")
private BigDecimal averageBidAmount;
```

## 数据库默认值
@org.hibernate.annotations.Generated 用来标记属性是

# 映射可嵌入组件
说白了就是支持一种类比表多的情况, 如 User 表中可以有 city,street,zipcode(邮政编码)

但是在 OOP 中我们可能是一个 User 类中有一个 Address 对象, 这时就有一个问题:在编程中类一般更细致
而数据库更粗粒度

Hibernate 可以很好的支持将粗粒度的数据库分解为更细粒度的类层次

在这个例子中我们可以将 Address 类标识为 @Embeddable, 或将 User 类中的属性标识为 @Embedded
```java
@Embeddable
public class Address {

    @Column(nullable = false)
    private String city;

    @Column(nullable = false, length = 5)
    private String street;

    @Column(nullable = false)
    private String zipcode;
    
    //省略 setter/getter
}
```

# 使用转换器映射 Java 和 SQL 类型

## 内置类型

## 自定义 JPA 类型转换器
JPA 中的一个标准扩展点 javax.persistence.AttributeConverter

这个类必须由 @Converter 注解标识或者用 orm.xml 元数据中声明它
```java
@Converter
public class MyConverter implements AttributeConverter<User,String> {

    @Override
    public String convertToDatabaseColumn(User user) {
        return null;
    }

    @Override
    public User convertToEntityAttribute(String s) {
        return null;
    }
}
```

# 映射继承关系
* 每个具体类使用一张表并且使用默认的运行时多态行为
* 每个具体类使用一张表但完全舍弃SQL架构的多态和继承关系, 将SQL UNION 查询用于运行时多态行为
> 此时数据库中有一张 hibernate\_sequence 表用来存下标
* 每个类层次结构使用一个表: 通过反规范化SQL架构来启用多态并且依赖基于行的区别来判定超类还是子类
* 每个子类使用一个表: 将 is a(继承) 关系表示为 has a(外键)关系, 并使用 SQL JOIN 操作


# 多态关联

# 映射集合和实体关联
重点是**@ElementCollecction** 注解
这个注解用于**值类型**元素的集合
映射 Set
@CollectionTable 和 @Column 用来重命名
```java
@Entity
public class Item {
    @ElementCollection
    @CollectionTable(
        name = "IMAGE",
        joinColumns = @JoinColumn(name = "ITEM_ID"))
    @Column(name = "filename")
    protected Set<String> images = new HashSet<>();
}
```


```java
@Entity
public class Item {
    @ElementCollection
    @CollectionTable( name = "IMAGE")
    @Column(name = "filename")
    @org.hibernate.annotations.CollectionId(
        Columns = @Column(name = "IMAGE_ID"),
        type = @org.hibernate.annotation.Type(type = "long"),
        generator = Constants.ID_GENERATOR //有问题
        )
    protected Collection<String> images = new ArrayList<>();
}
```


```java
@Entity
public class Item {
    @ElementCollection
    @CollectionTable( name = "IMAGE")
    @Column(name = "filename")
    @OrderColunm
    protected Collection<String> images = new ArrayList<>();
}
```


映射一个Map
```java
@Entity
public class Item {
    @ElementCollection
    @CollectionTable( name = "IMAGE")
    @MapKeyColumn(name = "FILENAME")
    @Column(name = "IMAGENAME")
    protected Map<String, String> images = new HashMap<>();
}
```


