# 映射值类型

## 映射基本属性
如果属性是基本属性或者其包装类型, 或者是 String, BigInteger, BigDecimal,
java.util.Date, java.util.Calendar, java.sql.Date, java.sql.Time, java.sql
.Timestamp, byte[], Byte[], char[] 和 Character[]

如果将属性的类注解为 @Embeddable, 或者将属性本身映射为 @Embedded,
则 Hibernate 会将该属性映射为所属类的可嵌入组件

如果属性的类型是 java.io.Serializable, 则会使用以其序列化格式存储


## 使用派生属性
@Formula(公式)

# 映射可嵌入组件
说白了就是支持一种类比表多的情况, 如 User 表中可以有 city,street,zipcode(邮政编码)

但是在 OOP 中我们可能是一个 User 类中有一个 Address 对象, 这时就有一个问题:在编程中类一般更细致
而数据库更粗粒度

Hibernate 可以很好的支持将粗粒度的数据库分解为更细粒度的类层次

在这个例子中我们可以将 Address 类标识为 @Embeddable, 或将 User 类中的属性标识为 @Embedded
```java
@Embeddable
public class Address {

    @Column(nullable = false)
    private String city;

    @Column(nullable = false, length = 5)
    private String street;

    @Column(nullable = false)
    private String zipcode;
    
    //省略 setter/getter
}
```

# 使用转换器映射 Java 和 SQL 类型

## 内置类型

## 自定义 JPA 类型转换器
JPA 中的一个标准扩展点 javax.persistence.AttributeConverter

这个类必须由 @Converter 注解标识或者用 orm.xml 元数据中声明它
```java
@Converter
public class MyConverter implements AttributeConverter<User,String> {

    @Override
    public String convertToDatabaseColumn(User user) {
        return null;
    }

    @Override
    public User convertToEntityAttribute(String s) {
        return null;
    }
}
```


# 映射继承关系
* 每个具体类使用一张表并且使用默认的运行时多态行为
* 每个具体类使用一张表但完全舍弃SQL架构的多态和继承关系, 将SQL UNION 查询用于运行时多态行为
* 每个类层次结构使用一个表: 通过反规范化SQL架构来启用多态并且依赖基于行的区别来判定超类还是子类
* 每个子类使用一个表: 将 is a(继承) 关系表示为 has a(外键)关系, 并使用 SQL JOIN 操作


