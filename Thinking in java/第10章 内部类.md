# 10.1创建内部类

如果想从外部类的非静态方法之外的任意位置创建某个内部类的对象,
那么必须具体地指明这个对象的类型: OuterClassName.InnerClassName

# 10.2链接到外部类

当生成一个内部类对象时, 此对象与制造它的外围对象(enclosing object)就有了一种联系,
所以它可以访问其外围对象的所有成员, 而不需要任何特殊条件.
此外, 内部类还拥有其外围类的所有元素的访问权.

当某个外围类的对象创建了一个内部类对象时, 此内部类对象会自动的捕获一个指向外围类对象的引用.
当你在内部类中访问外部类对象时其实使用那个引用访问.
所以内部类(内部类是非 static类时)对象只能在与外围类对象相关联的情况下才能被创建.
构建内部类对象时, 需要一个指向其外围类对象的引用, 如果编译器访问不到这个引用就会报错

# 10.3使用.this和.new
# 10.4向上转型
# 10.5在方法和作用域中的内部类
# 10.6匿名内部类
# 10.7嵌套类
指 **static **的内部类,因为它们不依赖于外部类,也就是说它们没有持有外部对象的引用,无法访问外部对象

普通内部类的字段与方法, 只能放在类的外部层次上, 所以普通内部类不能有 static 数据和 static 字段, 也不能包含嵌套类.
但是嵌套类可以包含这些
## 10.7.1 接口内部类
你放到接口中的任何类都自动地是 public 和 static 的. 因为类是 static 的,只是将嵌套类置于接口的命名空间内,
这并不违反接口的规则. 你甚至可以在内部类中实现其外围接口

# 10.8为什么需要内部类
每个内部类都能独立的继承自一个(接口)实现, 所以无论外围类是否已经继承了某个(接口的)实现, 对于内部类都没有影响
内部类使得多重继承的解决方案变得完整, 接口解决了部分问题, 而内部类有效的实现了 "多重继承"

# 10.8.1闭包与回调
闭包(closure) 是一个可调用对象, 它记录了一些信息, 这些信息来自于创建它的作用域
通过这个定义, 可以看出内部类是面向对象的闭包, 因为它不仅包含外围类对象的信息, 还自动拥有一个指向此外围类的引用

# 10.9内部类的继承
```java
    class WithInner{
        class Inner{ }
    }
    public class InheritInner extends WithInner.Inner{
        /*
        * 在继承内部类的时候的注意点
        * 要保持外部类的一个引用,所以要传入一个外部类实例, 这还不够要调用super()才行
        
        * */
        public InheritInner(WithInner wi){
            wi.super();
        }
        public static void main(String[] args) {
            WithInner wi = new WithInner();
            InheritInner ii = new InheritInner(wi);
        }
    }
```
