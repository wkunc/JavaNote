# 数组是第一级对象
无论使用哪种类型的数组, 数组的标识符其实只是一个引用, 指向在堆中创建的一个真实对象, 这个(数组)对象用以保存指向其他对象的引用, 可以作为数组初始化语法的一部分隐式的创建此对象, 或用 new 表达式显式地创建

只读成员 length 是数组对象的一部分(事实上, 这是唯一一个可以访问的字段或方法)

# Arrays 实用功能

## 复制数组

java 标准雷克提供又 static 方法 System.arraycopy() ,用它复制数组比用for 循环复制快的多, System.arraycopy() 针对所有的类型做了重载

## 数组的比较
Arrays 类提供了重载后的 eauals() 方法, 用来比较整个数组.

同样, 此方法针对所有基本类型和Object类型都做了重载

数组相等的条件是元素个数必须相同, 并且对应位置的元素也相等

## 数组元素的比较
排序必须根据对象的实际类型执行比较操作, 一种简单的解决方案是为每种不同的类型各编写一个不同的排序方法, 但是这样的代码难以被新的类型所复用

程序设计的基本目标是 "将保持不变的事务与会发生变化的事务相分离", 而这里,不变的是通用的排序算法, 变化的各种对象相互比较的方式

因此, 不是将进行比较的代码编写成不同的子程序, 而是使用 *策略设计模式*. 通过传递 *策略*, 可以将 "会发生变化的代码" 封装在单独的类中(策略对象), 你可以将策略对象传递给总是相同的代码, 这些代码将使用策略来完成其算法

在 Java 中有两种方式来提供比较功能:
* 让你的类事项 java.lang.Comparable 接口, 使你的类拥有"天生的"比较能力
* 创建一个 Comparator 接口的实现类(这是*策略模式*的一个应用实例)

## 数组排序
用内置的排序方法, 就可以对任意的基本类型数组排序, 也可以对任意的对象数组进行排序, 只要该对象实现了 Comparable 接口, 或者有相关联的 Comparator

### 注意
String 排序算法依据*字典编排顺序*排序, 所以大写字母开头的词都放在前面输出, 若想忽略大小写,使用 String.CASE_INSENSITIVE_ORDER(这是一个比较器的实现)

java 标准类库中的排序针对排序的类型做了优化, 如果是 基本类型设计了 *快排*, 如果是对象设计了 *稳定归并排序*

# 最后

在 Java 中,大多数情况下,容器已经是最好的选择
