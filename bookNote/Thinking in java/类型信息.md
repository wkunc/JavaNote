# 类型信息

本章讨论 java 是如何让我们在运行时识别对象和类的信息的, 主要两种方式

"传统的" RTTI *(Run-Time Type Identification)*, 它假定我们在编译时已经知道了所有的类型,

另一种是 "反射" 机制, 它允许我们在运行时发现和使用类的信息

# RTTI(Run-Time Type Identification)

因为有时需要获得一个对象的确切类信息来使用它特有的 API 而不是基类定义的接口

## Class 对象

要理解RTTI在Java中的工作原理, 首先必须知道类型信息在运行时是如何表示的.
这项工作是由被称为 Class 对象的*特殊对象*完成的, 它包含了与类有关的型.
事实上, Class对象就是用类创建类的所有的 "常规" 对象的.
Java使用Class对象来执行其RTTI, 即使是类型转换之类的操作.
Class 类还拥有大量的使用 RTTI 的其他方式.

所有的类都是在对其第一次使用时, 动态加载到 JVM 中的.
当程序创建第一个对类的静态成员的引用时, 就会加载这个类.
这也证明了**构造器**也是**类的静态方法**, 即使构造器没有使用static关键字.
使用 new 操作符创建类的新对象也会被当作对类的静态成员的引用.

### 泛化的Class引用

向Class引用添加泛型语法的原因仅仅是为了提供编译期类型检查.

## 反射 运行时的类信息

**反射机制** 并没有什么特殊之处, 当通过 **反射机制** 与一个未知类型的对象打交道时,
JVM 只是简单地检查这个对象, 看它属于哪个特定的类 (就像RTTI那样).
在用它做其他事情前必须先加载那个类的 Class 对象. 因此那个类的 *.class* 文件对于 JVM 来说必须是可获得的, 不论是本地还是网络

所以 **RTTI** 和 **反射** 的真正区别只在于, 对于RTTI来说, 编译器在编译时打开和检查 *.class* 文件,
而对于 **反射机制** 来说, *.class* 文件在编译期间时不可获取的, 所以是在运行是打开和检查 *.class* 文件

Java 中 Class 类 和 java.lang.reflect 类库一起对反射的概念进行了支持,
这个类库包含了**Field, Method 以及 Constructor** 类(每个类都实现了 **Member 接口**)这些对象由 JVM 在运行时创建, 用以表示
**未知类**里的对应成员

## 1.类方法提取器

通常你不需要直接使用 **反射工具** ,但是它们在你需要创建更加动态的代码时会很有用.

**反射** 在 java 中是用来支持其他特性的, 例如 **对象序列化** 和 JavaBean

反射是异常强大的, 任何 java代码,在反射面前会暴露一切信息, 不管是不是 private 还是内部类之类的方式, 都无法阻止反射

## 动态代理

