#+author: wkunc
#+date:<2023-07-28 五> 

* BootStrap

** AbstractBootstrap

#+begin_src java
// 设置ChannelFactory, 采用反射方式调用指定 Channel 的默认构造器
public B channel(Class<? extents C channelClass>) {
    return channelFactory(new ReflectiveChannelFactory<C>(channelClass)
}

// 创建 Channel 并绑定到指定到本地端口
// 通常是 Server 调用, 因为Client有 Connect 方法
private ChannelFutre doBind(final SocketAddress loaclAddress) {

}
#+end_src


#+begin_src java
public ChannelFuture doResolveAndConnect(final SocketAddress remoteAddress, final SocketAddress localAddress) {
    // 1. 用 ChnnelFactory 创建 Channel
    // 2. 将指定到 ChannelHandler 放到 pipline 到末尾, 配置Channel选项 
    // 3. 将Channel注册到指定到 EventLoopGroup
    final ChannelFuture regFuture = initAndRegister();
    final Channel channel = regFuture.channel();

    // 简化异常处理等步骤
    // 4. 
    return doResolveAndConnect0(final SocketAddress remoteAddress, final SocketAddress localAddress);
}
private ChannelFuture doResolveAndConnect0(final Channel channel, SocketAddress remoteAddress,
                                           final SocketAddress localAddress, final ChannelPromise promise) {

    // 获取 地址解析器, 复制解析远程地址
    AddressResolver<SocketAddress> resolver = this.resolver.getResolver(eventLoop);

    final Future<SocketAddress> resolveFuture = resolver.resolve(remoteAddress);

    doConnect(resolveFuture.getNow(), localAddress, promise);

}

// AbstractChannel 将 connect() 方法委托给 pipeline 实现
// DefaultChannelPipeline 实现调用 tail.connect(), 会经过所有ChannelHandler 最后到达HeadContext. 调用 Unsafe.connect 方法
private static void doConnect( final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise connectPromise) {
    final Channel channel = connectPromise.channel();
    if (localAddress == null) {
        channel.connect(remoteAddress, connectPromise);
    } else {
        channel.connect(remoteAddress, localAddress, connectPromise);
    }
}

#+end_src

* 事件顺序
| 事件         | 描述                                                         |
|--------------+--------------------------------------------------------------|
| Registered   | Channel和对应的EventLoop进行绑定, 即调用 EventLoop.registr() |
| Active       |                                                              |
| Read         |                                                              |
| ReadComplete |                                                              |
| Inactive     |                                                              |
| unRegistered |                                                              |


1. pipeline.fireChannelRegistered();

#+BEGIN_QUOTE
1. channel 与 IO线程(EventLoop) 绑定,
2. NIO执行 SocketChannel.register(selector, 0, this);
3. 通知所有的 ChannelHandler.handlerAdded(ctx)
4. 发送事件
#+END_QUOTE

2. pipeline.fireChannelActive();
#+BEGIN_QUOTE
在 Registered 后, 判断 isActive(), firstRegistration 发送 channelActive 事件
isActive() 对于NIOSocket 来说, ch.isOpen() && ch.isConnected(); 底层通道 open 并且已经建立连接时为激活状态.
NIOServerSocket 则是 isOpen() && javaChannel().socket().isBound(); 底层通道 open 并且已经监听本地端口时为激活状态.
Active 事件从 Head 开始传播. HeadContext 重写了 fireChannelActive(); 其他handler执行后, 会执行 readIfIsAutoRead() 方法(默认配置就是autoRead)
会调用 Channel.read() 方法. 而 AbstractChannel 实现了 read() 调用 pipeline.read(), 然后是从tail开始调用.最后会到head中的 read() 方法
HeadContext.read() 调用了 unsafe.beginRead() 方法. AbstractUnsafe.read() 调用抽象方法 doBeginRead() 处理异常
AbstractNioChannel 实现了 doBeginRead() 方法, 给关联的Channel 注册了 readInterestOp 字段的事件 (NioSocketChannel的构造器中初始化为 OP_READ)
此后NioEventLoop 的 run()的循环就可以获取到通道的 OP_READ 事件.
在NioEventLoop中的可以找到对应事件的处理方法, OP_READ事件会调用 unsafe.read()
NioByteUnsafe.read() 实现了从 javaChannel 中读取字节到 ByteBuf 的过程
#+END_QUOTE

4. pipeline.fireChannelRead(byteBuf);
5. pipeline.fireChannelReadComplete();


#+BEGIN_QUOTE
在循环读取 javaChannel 中的可读字节到结束后(没有可读字节了) 结束循环, 发送readCompleted() 事件. 从 Head 开始
Head 向下传递事件, 并在其他handler结束后,
(?存疑) 再次调用 readIfIsAutoRead() 完成 OP_READ 事件的注册(如果有需要的话, 某些情况下 read() 方法会移除 OP_READ)
#+END_QUOTE

* Netty client 初始化流程

#+begin_src java
public abstract class AbstractBootstrap<B extends AbstractBootstrap<B, C>, C extends Channel> implements Cloneable {

  // EventLoopGroup, 每个channel 会从中分配出一个线程进行绑定
  volatile EventLoopGroup group;
  // 相应Channel工厂, 抽象分离提供扩展的可能.
  // 默认提供了一个使用反射调用默认构造器的 ReflectiveChannelFactory
  private volatile ChannelFactory<? extends C> channelFactory;
  // 本地绑定端口
  private volatile SocketAddress localAddress;

  // channel的属性设置
  private final Map<ChannelOption<?>, Object> options = new LinkedHashMap<ChannelOption<?>, Object>();
  private final Map<AttributeKey<?>, Object> attrs = new ConcurrentHashMap<AttributeKey<?>, Object>();
  // 每个channel的handler (通常是 ChannelInitializer, 用来初始化 Channel的handler)
  private volatile ChannelHandler handler;


  // 初始化并在EventLoop注册channel
  final ChannelFuture initAndRegister() {
    Channel channel = null;
    try {
      // 1. 默认情况下等于调用对应 Channel 实现类的默认构造器
      channel = channelFactory.newChannel();
      // 2. 初始化channel, 抽象方法由子类实现
      init(channel);
    } catch (Throwable t) {
      if (channel != null) {
        // channel can be null if newChannel crashed (eg SocketException("too many open files"))
        channel.unsafe().closeForcibly();
        // as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor
        return new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);
      }
      // as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor
      return new DefaultChannelPromise(new FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);
    }

    // 3. 在 EventLoopGroup 上注册, EventLoopGroup 的逻辑基本都为给通道分配一个 EventLoop 然后在调用其的register方法.
    // 而所有的EventLoop都继承于SingleThreadEventLoop, 实现了register() 方法.
    // 调用 channel.unsafe().register(). 所以最后是调用了 NioChannel.NioUnsafe.register()
    ChannelFuture regFuture = config().group().register(channel);
    if (regFuture.cause() != null) {
      if (channel.isRegistered()) {
        channel.close();
      } else {
        channel.unsafe().closeForcibly();
      }
    }

    // If we are here and the promise is not failed, it's one of the following cases:
    // 1) If we attempted registration from the event loop, the registration has been completed at this point.
    //    i.e. It's safe to attempt bind() or connect() now because the channel has been registered.
    // 2) If we attempted registration from the other thread, the registration request has been successfully
    //    added to the event loop's task queue for later execution.
    //    i.e. It's safe to attempt bind() or connect() now:
    //         because bind() or connect() will be executed *after* the scheduled registration task is executed
    //         because register(), bind(), and connect() are all bound to the same thread.

    return regFuture;
  }

}
#+end_src 

#+begin_src java
    protected abstract class AbstractUnsafe implements Unsafe {

        @Override
        public final void register(EventLoop eventLoop, final ChannelPromise promise) {
            ObjectUtil.checkNotNull(eventLoop, "eventLoop");
            if (isRegistered()) {
                promise.setFailure(new IllegalStateException("registered to an event loop already"));
                return;
            }
            if (!isCompatible(eventLoop)) {
                promise.setFailure(
                        new IllegalStateException("incompatible event loop type: " + eventLoop.getClass().getName()));
                return;
            }

            AbstractChannel.this.eventLoop = eventLoop;

            if (eventLoop.inEventLoop()) {
                register0(promise);
            } else {
                try {
                    eventLoop.execute(new Runnable() {
                        @Override
                        public void run() {
                            register0(promise);
                        }
                    });
                } catch (Throwable t) {
                    logger.warn(
                            "Force-closing a channel whose registration task was not accepted by an event loop: {}",
                            AbstractChannel.this, t);
                    closeForcibly();
                    closeFuture.setClosed();
                    safeSetFailure(promise, t);
                }
            }
        }

        private void register0(ChannelPromise promise) {
            try {
                // check if the channel is still open as it could be closed in the mean time when the register
                // call was outside of the eventLoop
                if (!promise.setUncancellable() || !ensureOpen(promise)) {
                    return;
                }
                boolean firstRegistration = neverRegistered;
                doRegister();
                neverRegistered = false;
                registered = true;

                // 确保在通知 promise 之前先调用 handlerAdded() 方法通知handler Add Event事件
                // (因为有些Handler会利用Add Event事件完成延迟初始化之类的行为才能正常工作)
                // 而这个 promise 上存在用户添加的ChannelFutureListener, 里可能有 fire event 动作. 需要保障所有handler都准备好了.
                pipeline.invokeHandlerAddedIfNeeded();

                // 设置promise的成功结果 
                safeSetSuccess(promise);
                // 触发 registered 事件
                pipeline.fireChannelRegistered();
                // Only fire a channelActive if the channel has never been registered. This prevents firing
                // multiple channel actives if the channel is deregistered and re-registered.
                if (isActive()) {
                    if (firstRegistration) {
                        pipeline.fireChannelActive();
                    } else if (config().isAutoRead()) {
                        // This channel was registered before and autoRead() is set. This means we need to begin read
                        // again so that we process inbound data.
                        //
                        // See https://github.com/netty/netty/issues/4805
                        beginRead();
                    }
                }
            } catch (Throwable t) {
                // Close the channel directly to avoid FD leak.
                closeForcibly();
                closeFuture.setClosed();
                safeSetFailure(promise, t);
            }
        }
    }
#+end_src 

** Connect 流程

#+begin_src java
public class Bootstrap extends AbstractBootstrap<Bootstrap, Channel> {

  private ChannelFuture doResolveAndConnect(final SocketAddress remoteAddress, final SocketAddress localAddress) {
    // 1. 创建并初始化一个 Channel, 调用AbstractBootstrap中定义的方法
    final ChannelFuture regFuture = initAndRegister();
    final Channel channel = regFuture.channel();

    // 2. 保证在 regFuture 之后执行 doResolveAndConnect0(); 进行connect
    if (regFuture.isDone()) {
      if (!regFuture.isSuccess()) {
        return regFuture;
      }
      return doResolveAndConnect0(channel, remoteAddress, localAddress, channel.newPromise());
    } else {
      // Registration future is almost always fulfilled already, but just in case it's not.
      final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);
      regFuture.addListener(new ChannelFutureListener() {
        @Override
        public void operationComplete(ChannelFuture future) throws Exception {
          // Directly obtain the cause and do a null check so we only need one volatile read in case of a
          // failure.
          Throwable cause = future.cause();
          if (cause != null) {
            // Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an
            // IllegalStateException once we try to access the EventLoop of the Channel.
            promise.setFailure(cause);
          } else {
            // Registration was successful, so set the correct executor to use.
            // See https://github.com/netty/netty/issues/2586
            promise.registered();
            doResolveAndConnect0(channel, remoteAddress, localAddress, promise);
          }
        }
      });
      return promise;
    }
  }
}

#+end_src

