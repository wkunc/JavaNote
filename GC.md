# JVM重要指标
1. Maximun Pause Time Goal(最大暂停时间目标)

-XX:MaxGCPauseMillis=<nnn>
设置一次GC最大的暂停时间, 没有默认值

2. Throughput Goal(吞吐量目标)

-XX:GCTimeRatio=<nnn>
这里随着的是应用时间和GC时间的比例, GC时间份数为1
比如 -XX:GCTimeRatio=19
那么GC占总时间就为 1 / (1 + 19) = 5%
(这里说的GC时间是年轻代和老年代手机的总时间之和)

3. Footprint Goal(最小化占用内存, Footprint 除了脚印还有占地面积的意思,在此可以理解为占用内存)
在达到前两个目标的基础上,会缩小堆大小直到某一个目标无法达成. 然后尝试解决
PS: 看描述应该就是在保证前两个目标的情况下, 尽力保证占用的堆内存最小化

暂停时间目标与吞吐量目标的关系.
1. 如果想要较小的暂停时间(即实时性), 那么heap应比较小. 因为小堆GC起来肯定比一个大堆快. 但是此时由于堆较小, 所以经常触发GC.导致吞吐量不高(总体来说GC花费的时间多了)
2. 如果想要较高的吞吐量, 那么heap应该比较大, 这样就不容易触发GC. 但是完成一次GC的时间就会较长所以就不能保持较小的暂停时间.
> 比如说一个大堆GC一次可能要100ms, 一个小堆GC一次要10ms. 那么如果小堆触发10次GC之后, 大堆才触发


# Tuning Strategy(调优策略)

1. 除非明确知道需要的堆大于默认的最大堆大小, 否则不要为堆指定最大值


# GC 实现
根据从事实经验总结的weak generational hypothesis(弱世代假说, 即大多数对象只能存活很短的时间),
重点关注大部分对象都'die young'的事实, 可以实现更高效的GC算法(即分代思想)

1. 内存以代为单位进行管理(内存池包含不同年龄的对象). 当代填满时,垃圾收集发生在每一代中.
2. 大多数对象都分配在年轻代, 大多数对象会在那里消. 当年轻代填满时进行 `Minor GC`, 只收集年轻代.
这种收集的成本和存活对象的数量成正比, 充满死对象的年轻代收集的非常快.
3. 每次 Minor GC 期间年轻代中幸存的对象的一部分会移动到老年代. 最终老年代被填满从而导致 `Major GC`, 收集整个堆.


# Minor GC vs Major GC vs Full GC
